import re
import sys
import os
import numpy as np
from collections import namedtuple
import tables
import RegDB.experiment_info

abspath=(os.path.abspath(os.path.dirname(__file__))).replace('/examples','')
sys.path.append(abspath)
sys.path.append(abspath+'/smalldata_tools')

from utilities import dictToHdf5
from GaussFit import GaussFit

uxi_shape = (1024, 512)
uxiDarkRuns = [32,36,57,71,72,80,86,109]
uxiHistogramEdges = np.arange(-150,200)

def getUxiDict(run):
    ##
    # get timestamp range for xtc file (???)
    ##
    runsDict = RegDB.experiment_info.experiment_runs('xcs','xcsx31116')
    xtcBeginTime=None
    xtcEndTime=None
    for thisRun in runsDict:
        if thisRun['num']==int(run):
            xtcBeginTime = int(thisRun['begin_time_unix'])
            xtcEndTime = int(thisRun['end_time_unix'])
    ##
    # put some UXI stuff here.
    ##
    uxiPath='/reg/d/psdm/xcs/xcsx31116/usrdaq/uxi/'
    #start with actual run first.
    fname='uxi_x311_%04d.dat'%int(run)
    fnamePre='uxi_x311_%04d.dat'%(int(run)-1)
    if int(run) == 19: #yes, this is special....
        fnamePre='uxi_x311_%04d.dat'%(int(run)-2)
    fnamePost='uxi_x311_%04d.dat'%(int(run)+1)

    print 'look for uxi: ',uxiPath+fname
    minUxi=None; maxUxi=None
    print 'xtc begin: ',xtcBeginTime, xtcEndTime

    uxiDict={}
    configDict=fillUxiDict(uxiPath+fname, xtcBeginTime, xtcEndTime, uxiDict)
    #print configDict

    #print 'DEBUG times: ',xtcBeginTime,minUxi
    if minUxi is None:
        print 'here:',fnamePre
        configDict=fillUxiDict(uxiPath+fnamePre, xtcBeginTime, xtcEndTime, uxiDict)
    if xtcBeginTime<minUxi and os.path.isfile(uxiPath+fnamePre):
        print 'checking the run before....'
        fillUxiDict(uxiPath+fnamePre, xtcBeginTime, xtcEndTime, uxiDict)

    if xtcEndTime>maxUxi and os.path.isfile(uxiPath+fnamePost):
        print 'checking the run after....'
        fillUxiDict(uxiPath+fnamePost, xtcBeginTime, xtcEndTime, uxiDict)
    
    return uxiDict, configDict


def fillUxiDict(fname, xtcBeginTime, xtcEndTime, uxiDict, debug=False):
    if not os.path.isfile(fname): return
    dataDictTS = {}
    #read the uxi file, get dict of frame fids&evttimes & images & config.
    t_preUxiRead=time.time()
    dataDictTS['uxi'] = get_uxi_timestamps(fname)    
    
    print 'UXI file ',fname, dataDictTS['uxi']['lcls_ts_secs']
    minUxi = int(min(dataDictTS['uxi']['lcls_ts_secs']))
    maxUxi = int(max(dataDictTS['uxi']['lcls_ts_secs']))
    if debug: print 'min/max time: ',minUxi, maxUxi
    
    configDict=None
    #if uxi event time stamps lie in uxi range, get all uxi data
    if minUxi<=xtcEndTime and maxUxi>=xtcBeginTime:
        inXtc = np.array([(int(ts) >= xtcBeginTime and int(ts) <= xtcEndTime) for ts in dataDictTS['uxi']['lcls_ts_secs']])
        uxiDictAll,configDict = read_uxi(fname, returnConfig=True)    
        for key in uxiDictAll.keys():
            if key not in uxiDict.keys():
                uxiDict[key] = np.array((uxiDictAll[key]))[inXtc]
            else:
                uxiDict[key] = np.append(uxiDict[key], np.array((uxiDictAll[key]))[inXtc], axis=0)
        if debug: print 'check lengths: ',len(uxiDictAll['lcls_ts_secs']),' inXtc: ',inXtc.sum(),' out dict ',len(uxiDict['lcls_ts_secs'])
    return configDict

def read_uxi(fname, returnConfig=False):
    header = re.compile("#\s+Frame\s+header\s+info:\s+(?P<meta>.*)")
    config_pat = re.compile("#\s+Config:\s+(?P<conf>.*)")
    pat = re.compile("\s+")
    config = None
    Metadata = None
    MetadataList = []
    configDict={}
    with open(fname, 'r') as infile:
        dataDict={}
        #nline=0 #DEBUG
        while True:
            line = infile.readline()
            if not line:
                break
            #nline+=1 #DEBUG
            #if nline>10: #DEBUG
            #             break
            if line.startswith("#"):
                config_match = config_pat.match(line)
                header_match = header.match(line)
                if header_match:
                    Metadata = namedtuple('Metadata', header_match.group("meta"))
                elif config_match:
                    configDict = eval(config_match.group("conf"))
                    print configDict
                continue
            frameA = np.reshape(np.load(infile), uxi_shape)
            frameB = np.reshape(np.load(infile), uxi_shape)
            metadata = Metadata._make(pat.split(line.rstrip()))

            if 'frameA' not in dataDict.keys():
                dataDict['frameA'] = [frameA]
            else:
                dataDict['frameA'].append(frameA)
            if 'frameB' not in dataDict.keys():
                dataDict['frameB'] = [frameB]
            else:
                dataDict['frameB'].append(frameB)

            MetadataDict = metadata._asdict()
            for key in MetadataDict.keys():
                if key not in dataDict.keys():
                    dataDict[key] = [MetadataDict[key]]
                else:
                    dataDict[key].append(MetadataDict[key])

            #print(metadata)
            #print(frameA)
            #print(frameB)

        if returnConfig:
            return dataDict, configDict
        else:
            return dataDict



def uxi_pedestal(fname):
    header = re.compile("#\s+Frame\s+header\s+info:\s+(?P<meta>.*)")
    config_pat = re.compile("#\s+Config:\s+(?P<conf>.*)")
    pat = re.compile("\s+")
    config = None
    Metadata = None
    MetadataList = []
    with open(fname, 'r') as infile:
        dataDict={}
        #nline=0 #DEBUG
        while True:
            line = infile.readline()
            if not line:
                break
            if line.startswith("#"):
                config_match = config_pat.match(line)
                header_match = header.match(line)
                if header_match:
                    Metadata = namedtuple('Metadata', header_match.group("meta"))
                elif config_match:
                    configDict = eval(config_match.group("conf"))
                    print configDict
                continue
            frameA = np.load(infile)
            frameB = np.load(infile)
            metadata = Metadata._make(pat.split(line.rstrip()))

            frameA = np.reshape(np.array(frameA), uxi_shape )
            frameB = np.reshape(np.array(frameB), uxi_shape )

            if 'frameA' not in dataDict.keys():
                dataDict['frameA'] = [frameA]
            else:
                dataDict['frameA'].append(frameA)
            if 'frameB' not in dataDict.keys():
                dataDict['frameB'] = [frameB]
            else:
                dataDict['frameB'].append(frameB)

            #print(metadata)
            #print(frameA)
            #print(frameB)

    runStr = fname.split('_')[-1].replace('.dat','')
    print 'fname ',fname, runStr
    run = int(runStr)
    fnameOut='/reg/d/psdm/xcs/xcsx31116/calib/uxi/Run%04d_pedestals.h5'%run

    outDict={}
    #outDict['meanA'] = np.reshape(np.array(dataDict['frameA'])[1:].mean(axis=0), uxi_shape)
    #outDict['medA']  = np.reshape(np.median(np.array(dataDict['frameA'])[1:],axis=0), uxi_shape)
    #outDict['meanB'] = np.reshape(np.array(dataDict['frameB'])[1:].mean(axis=0), uxi_shape)
    #outDict['medB']  = np.reshape(np.median(np.array(dataDict['frameB'])[1:],axis=0), uxi_shape)
    outDict['meanA'] = np.array(dataDict['frameA'])[1:].mean(axis=0)
    outDict['medA']  = np.median(np.array(dataDict['frameA'])[1:],axis=0)
    outDict['meanB'] = np.array(dataDict['frameB'])[1:].mean(axis=0)
    outDict['medB']  = np.median(np.array(dataDict['frameB'])[1:],axis=0)
    outDict['rawA']  = np.array(dataDict['frameA'])
    outDict['rawB']  = np.array(dataDict['frameB'])

    dictToHdf5(fnameOut,outDict)
    

def get_uxi_timestamps(fname):
    header = re.compile("#\s+Frame\s+header\s+info:\s+(?P<meta>.*)")
    config_pat = re.compile("#\s+Config:\s+(?P<conf>.*)")
    pat = re.compile("\s+")
    config = None
    Metadata = None
    MetadataList = []
    with open(fname, 'r') as infile:
        dataDict={}
        #nline=0 #DEBUG
        while True:
            line = infile.readline()
            if not line:
                break
            if line.startswith("#"):
                config_match = config_pat.match(line)
                header_match = header.match(line)
                if header_match:
                    Metadata = namedtuple('Metadata', header_match.group("meta"))
                elif config_match:
                    continue
                    #config = eval(config_match.group("conf"))
                    #print("Config: %s"%config)
                continue
            frameA = np.load(infile)
            frameB = np.load(infile)
            metadata = Metadata._make(pat.split(line.rstrip()))

            MetadataDict = metadata._asdict()
            for key in MetadataDict.keys():
                if key not in dataDict.keys():
                    dataDict[key] = [MetadataDict[key]]
                else:
                    dataDict[key].append(MetadataDict[key])

        return dataDict

def getDarks(run, useMed=True):
    iDark=-1
    for d in uxiDarkRuns:
        if d > run: continue
        iDark=d
    if iDark<0: iDark=uxiDarkRuns[0]

    dat = tables.open_file('/reg/d/psdm/xcs/xcsx31116/calib/uxi/Run%04d_pedestals.h5'%iDark)
    if useMed: return iDark, dat.root.medA,dat.root.medB
    else: return iDark,dat.root.meanA,dat.root.meanB

def getUnbonded(frame, useMed=True):
    if frame.shape != uxi_shape:
        print 'frame does not have right shape, expected ',uxi_shape,', and got ',frame.shape
        return
    unbData = frame[:,255:257]
    if useMed:
        return np.nanmedian(unbData)
    else:
        return np.nanmean(unbData)

#FIX ME
#this is actually a fit of the low intensity part of the spectrum, NOT the zero photon (or first) peak.
def getZeroPeakFit(frame, histogramEdges=None):
    if histogramEdges is None:
        histogramEdges = uxiHistogramEdges
    his = np.histogram(frame.flatten(), histogramEdges)
    #print his[0]
    fitResult = GaussFit(his[0])
    #print fitResult
    #print 'DEBUG: ',fitResult['mean_estimate'],(fitResult['mean_estimate']!=np.nan),np.isnan(fitResult['mean_estimate'])
    meanVal = fitResult['mean']
    if np.isnan(fitResult['mean_estimate']):
        return fitResult
    if fitResult['mean_estimate'] < his[1].shape:
        fitResult['mean_estimate']=float(his[1][fitResult['mean_estimate']])
    else:
        fitResult['mean_estimate']=np.nan
    if int(meanVal)+(his[1][1]-his[1][0])*(meanVal-int(meanVal)) < his[1].shape:
        fitResult['mean']=float(his[1][int(meanVal)+(his[1][1]-his[1][0])*(meanVal-int(meanVal))])
    else:
        fitResult['mean']=np.nan
    #print 'mean in x: ',fitResult
    return fitResult
